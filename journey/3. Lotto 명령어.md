# 3. Lotto 명령어

벌써 세 번째 문서에 오셨네요.

작심삼일이라는 말이 있죠?

지금까지 분량이 너무 많아서 지금이 3일째가 아니려나요..?ㅎㅎ;;

아무튼, 차근차근 가다보면 어느새 나만의 멋진 봇이 만들어질 겁니다!

오늘도 자신을 위해서 달려가고 있는 여러분들을 응원합니다.

---

[지난 문서](./2.%20Ping-Pong%20명령어.md)에서 다음에는 "입력을 받아서 출력"하는 명령어와,

"명령어가 2개 이상일 땐 어떻게 처리해야 하는지"를 다루겠다고 했습니다.

단순히 "입력 > 출력"만 하면 재미 없으니까, 어떻게 만들어볼까 고민하다가.. 로또 시스템을 직접 만들어보려고 해요.

**오늘도 지난 문서처럼 딱! 딱! 포인트만 짚으면서 넘어갑니다!**

이젠 그냥 작업하는 순서를 기준으로 설명하겠습니다. (파일 기준으로 설명X)

그래서 조금 설명 자체가 복잡해 질 수는 있지만, 따라하기에는 더욱 수월할 것입니다! 홧팅!!

---

## 🎫 로또란?

1부터 45까지 숫자 중, 6개의 숫자를 중복없이 랜덤으로 선택해야 합니다.

이때, 사용자는 수동으로 직접 번호를 선택할 수도, 자동으로 무작위 숫자를 선택할 수 있습니다.

그리고, 로또의 당첨 숫자 중 나머지 숫자에서 1개의 숫자를 보너스번호로 자동으로 선택이 되는데, 사용자가 직접 고르지 않습니다.

1등은 사용자가 선택한 6개의 번호가 모두 일치할 때,

2등은 사용자가 선택한 5개의 번호와 보너스번호가 일치할 때,

3등은 사용자가 선택한 5개의 번호가 일치할 때,

4등은 사용자가 선택한 4개의 번호가 일치할 때,

5등은 사용자가 선택한 3개의 번호가 일치할 때이고,

1등 ~ 3등은 판매액과 당첨자 수에 따라 당첨금이 달라지고,

4등은 5만원으로, 5등은 5천원으로 금액이 정해져 있습니다.

일단, 금액은 이번 문서에서는 구현하지 않을 예정입니다.

명령어의 포맷은 아래처럼 할 예정입니다.

입력: `/lotto [자동/6개의 숫자 입력]`

출력

```
입력한 번호(자동/수동일 경우엔 표시 안 함): OO OO OO OO OO OO
당첨 번호: OO OO OO OO OO OO + (보너스 숫자)
등수: O등 당첨! (O개 + 보너스 번호 일치 여부 / 혹은 "꽝!")
```

---

## 🗂️ 파일 구조

보통 간단하게 프로그램을 만든다면, 하나의 파일안에 다 때려박을 수도 있고,

[`ping.go`](./2.%20Ping-Pong%20명령어.md)처럼 하나의 명령어 파일에 때려박을수도 있습니다.

하지만, 프로젝트가 커지고, 협업하게 되고, 유지보수가 필요할 경우, 보통 파일별로 기능을 나누게 됩니다.

아래와 같은 기준으로 분리하면, 명령어가 여러 개일 때도 각 기능별로 코드가 잘 정리되고,

하나의 파일이 지나치게 커지는 문제를 예방할 수 있습니다.

~~또한, 실무에서 쌍욕을 안 먹을 수 있습니다ㅎ~~

`main.go`
- 프로그램의 **진입점** 역할로, **main함수는 항상 최대한 간단하게 유지**하는 게 좋습니다. 
- 환경설정, 세션 생성, 핸들러 등록 등만 담당하고, 실제 명령어 처리/분기는 `commands/core.go` 에서 처리합니다.

`commands/core.go`
- [`ping.go`](./2.%20Ping-Pong%20명령어.md)에서 만들었던 `OnInteractionCreate` 등 이벤트 핸들러를 처리해, 명령어 이름별로 분기합니다.
- 이 파일에서 각 명령어별 함수를 호출하게 됩니다.
- 즉, 핵심 분기와 핸들러를 별도 파일로 분리하게 됩니다.

`commands/ping.go`, `commands/lotto.go`
- 각 명령어의 실제 처리 로직만 담당합니다.
- 즉, 명령어별 파일을 분리하게 됩니다.

---

## 🗂️ Refactoring

Refactoring(리팩토링)은 코드의 기능을 변경하지 않고 내부 구조를 개선하는 작업을 의미합니다.

더욱 깔끔하고 효율적으로 만드는 작업이라고 생각하시면 됩니다.

---

### ping.go → core.go (명령어 핸들러)

기존에 ping.go 파일은

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	ping := s.HeartbeatLatency().Milliseconds()
	if i.ApplicationCommandData().Name == "ping" {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

이렇게 OnInteractionCreate 핸들러가 있었는데, 이 부분을 `commands/core.go`로 옮겨줍니다.

```
// commands/core.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
    내부 생략
}
```

여기에서, 조건문 `if i.ApplicationCommandData().Name == "ping"` 이 분기점 역할을 하고 있으므로, 조건문을 기준으로 쪼개주도록 하겠습니다.

그런데, if를 쓸까요? 아니면 switch를 쓸까요? ~~(여기까지 다 C/C++에서 배웠었죠?)~~

if문은 복잡한 조건, 논리 연산, 범위 비교, 값의 존재 여부 등 다양한 조건을 조합해서 분기할 때 사용합니다.

즉, 2~3가지 분기나 복잡한 조건에 적합합니다.

switch문은 하나의 값이 여러 가지 케이스 중 어떤 것과 일치하는지 분기할 때 사용합니다.

따라서, 분기가 많아질수록 가독성, 유지보수성이 뛰어나고, 컴파일러가 최적화(jump table 등)로 성능상 이점도 있습니다.

그래서, 저 같으면 **switch문을 사용**해서, **표현식은 1번만** 쓰고, **값에 따라서 분기**하는 방법을 선택할 예정입니다.

`i.ApplicationCommandData().Name` 를 switch문의 표현식에 넣어주고, "ping"을 case에 넣어줍니다.

그리고, 그 밑에 있는 코드들은 모두 case가 "ping"일 때로 넣어주면 되겠죠?

Go 언어에서는 각 case 블록이 실행된 후, 자동으로 switch문을 빠져나가기 때문에 break문을 쓰지 않아도 됩니다. (fallthrough 자동 방지)

따라서, 현재까지 수정한 결과는 아래와 같습니다.

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	switch i.ApplicationCommandData().Name {
	case "ping":
		ping := s.HeartbeatLatency().Milliseconds()
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

---

### core.go → ping.go (명령어 처리)

`commands/core.go` 에서 `ping`의 내부 로직을 `commands/ping.go`에 함수를 만들어서 옮겨줍니다.

함수명에 `handle`을 접두사로 붙여, 나중에 명령어 처리 함수만 찾을 수 있도록, 그리고 일관성 있게 관리할 수 있도록 하겠습니다.

```
// commands/ping.go

func handlePing(s *discordgo.Session, i *discordgo.InteractionCreate) {
    생략
}
```

```
// commands/core.go

case "ping":
    handlePing(s, i)
}
```

둘 다 모두 같은 패키지(commands)에 존재하면서, Ping의 로직은 다른 패키지에서 사용할 일이 없으니깐, private로 설정햇습니다.

---

### main.go

원래는 수정해야 하지만, 패키지 이름과 함수 이름이 동일하기 때문에, 자동으로 수정이 된 것 같습니다.

혹시나 오류가 발생한다면 `Sketchbook.AddHandler(commands.OnInteractionCreate)` 이 부분의 인자가 제대로 된 경로인지 확인하세요.

---

