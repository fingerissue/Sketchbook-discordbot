# 3. Lotto 명령어

벌써 세 번째 문서에 오셨네요.

작심삼일이라는 말이 있죠?

지금까지 분량이 너무 많아서 지금이 3일째가 아니려나요..?ㅎㅎ;;

아무튼, 차근차근 가다보면 어느새 나만의 멋진 봇이 만들어질 겁니다!

오늘도 자신을 위해서 달려가고 있는 여러분들을 응원합니다.

---

[지난 문서](./2.%20Ping-Pong%20명령어.md)에서 다음에는 "입력을 받아서 출력"하는 명령어와,

"명령어가 2개 이상일 땐 어떻게 처리해야 하는지"를 다루겠다고 했습니다.

단순히 "입력 > 출력"만 하면 재미 없으니까, 어떻게 만들어볼까 고민하다가.. 로또 시스템을 직접 만들어보려고 해요.

**오늘도 지난 문서처럼 딱! 딱! 포인트만 짚으면서 넘어갑니다!**

이젠 그냥 작업하는 순서를 기준으로 설명하겠습니다. (파일 기준으로 설명X)

그래서 조금 설명 자체가 복잡해 질 수는 있지만, 따라하기에는 더욱 수월할 것입니다! 홧팅!!

---

## 🎫 로또란?

1부터 45까지 숫자 중, 6개의 숫자를 중복없이 랜덤으로 선택해야 합니다.

이때, 사용자는 수동으로 직접 번호를 선택할 수도, 자동으로 무작위 숫자를 선택할 수 있습니다.

그리고, 로또의 당첨 숫자 중 나머지 숫자에서 1개의 숫자를 보너스번호로 자동으로 선택이 되는데, 사용자가 직접 고르지 않습니다.

1등은 사용자가 선택한 6개의 번호가 모두 일치할 때,

2등은 사용자가 선택한 5개의 번호와 보너스번호가 일치할 때,

3등은 사용자가 선택한 5개의 번호가 일치할 때,

4등은 사용자가 선택한 4개의 번호가 일치할 때,

5등은 사용자가 선택한 3개의 번호가 일치할 때이고,

1등 ~ 3등은 판매액과 당첨자 수에 따라 당첨금이 달라지고,

4등은 5만원으로, 5등은 5천원으로 금액이 정해져 있습니다.

일단, 금액은 이번 문서에서는 구현하지 않을 예정입니다.

명령어의 포맷은 아래처럼 할 예정입니다.

입력: `/lotto [자동/6개의 숫자 입력]`

출력

```
입력한 번호(자동/수동일 경우엔 표시 안 함): OO OO OO OO OO OO
당첨 번호: OO OO OO OO OO OO + (보너스 숫자)
등수: O등 당첨! (O개 + 보너스 번호 일치 여부 / 혹은 "꽝!")
```

---

## 🗂️ 파일 구조

보통 간단하게 프로그램을 만든다면, 하나의 파일안에 다 때려박을 수도 있고,

[`ping.go`](./2.%20Ping-Pong%20명령어.md)처럼 하나의 명령어 파일에 때려박을수도 있습니다.

하지만, 프로젝트가 커지고, 협업하게 되고, 유지보수가 필요할 경우, 보통 파일별로 기능을 나누게 됩니다.

아래와 같은 기준으로 분리하면, 명령어가 여러 개일 때도 각 기능별로 코드가 잘 정리되고,

하나의 파일이 지나치게 커지는 문제를 예방할 수 있습니다.

~~또한, 실무에서 쌍욕을 안 먹을 수 있습니다ㅎ~~

`main.go`
- 프로그램의 **진입점** 역할로, **main함수는 항상 최대한 간단하게 유지**하는 게 좋습니다. 
- 환경설정, 세션 생성, 핸들러 등록 등만 담당하고, 실제 명령어 처리/분기는 `commands/core.go` 에서 처리합니다.

`commands/core.go`
- [`ping.go`](./2.%20Ping-Pong%20명령어.md)에서 만들었던 `OnInteractionCreate` 등 이벤트 핸들러를 처리해, 명령어 이름별로 분기합니다.
- 이 파일에서 각 명령어별 함수를 호출하게 됩니다.
- 즉, 핵심 분기와 핸들러를 별도 파일로 분리하게 됩니다.

`commands/ping.go`, `commands/lotto.go`
- 각 명령어의 실제 처리 로직만 담당합니다.
- 즉, 명령어별 파일을 분리하게 됩니다.

---

## 🗂️ Refactoring

Refactoring(리팩토링)은 코드의 기능을 변경하지 않고 내부 구조를 개선하는 작업을 의미합니다.

더욱 깔끔하고 효율적으로 만드는 작업이라고 생각하시면 됩니다.

---

### ping.go → core.go (명령어 핸들러)

기존에 ping.go 파일은

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	ping := s.HeartbeatLatency().Milliseconds()
	if i.ApplicationCommandData().Name == "ping" {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

이렇게 OnInteractionCreate 핸들러가 있었는데, 이 부분을 `commands/core.go`로 옮겨줍니다.

```
// commands/core.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
    내부 생략
}
```

여기에서, 조건문 `if i.ApplicationCommandData().Name == "ping"` 이 분기점 역할을 하고 있으므로, 조건문을 기준으로 쪼개주도록 하겠습니다.

그런데, if를 쓸까요? 아니면 switch를 쓸까요? ~~(여기까지 다 C/C++에서 배웠었죠?)~~

if문은 복잡한 조건, 논리 연산, 범위 비교, 값의 존재 여부 등 다양한 조건을 조합해서 분기할 때 사용합니다.

즉, 2~3가지 분기나 복잡한 조건에 적합합니다.

switch문은 하나의 값이 여러 가지 케이스 중 어떤 것과 일치하는지 분기할 때 사용합니다.

따라서, 분기가 많아질수록 가독성, 유지보수성이 뛰어나고, 컴파일러가 최적화(jump table 등)로 성능상 이점도 있습니다.

그래서, 저 같으면 **switch문을 사용**해서, **표현식은 1번만** 쓰고, **값에 따라서 분기**하는 방법을 선택할 예정입니다.

`i.ApplicationCommandData().Name` 를 switch문의 표현식에 넣어주고, "ping"을 case에 넣어줍니다.

그리고, 그 밑에 있는 코드들은 모두 case가 "ping"일 때로 넣어주면 되겠죠?

Go 언어에서는 각 case 블록이 실행된 후, 자동으로 switch문을 빠져나가기 때문에 break문을 쓰지 않아도 됩니다. (fallthrough 자동 방지)

따라서, 현재까지 수정한 결과는 아래와 같습니다.

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	switch i.ApplicationCommandData().Name {
	case "ping":
		ping := s.HeartbeatLatency().Milliseconds()
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

---

### core.go → ping.go (명령어 처리)

`commands/core.go` 에서 `ping`의 내부 로직을 `commands/ping.go`에 함수를 만들어서 옮겨줍니다.

함수명에 `handle`을 접두사로 붙여, 나중에 명령어 처리 함수만 찾을 수 있도록, 그리고 일관성 있게 관리할 수 있도록 하겠습니다.

```
// commands/ping.go

func handlePing(s *discordgo.Session, i *discordgo.InteractionCreate) {
    생략
}
```

```
// commands/core.go

case "ping":
    handlePing(s, i)
}
```

둘 다 모두 같은 패키지(commands)에 존재하면서, Ping의 로직은 다른 패키지에서 사용할 일이 없으니깐, private로 설정햇습니다.

---

### main.go

원래는 수정해야 하지만, 패키지 이름과 함수 이름이 동일하기 때문에, 자동으로 수정이 된 것 같습니다.

혹시나 오류가 발생한다면 `Sketchbook.AddHandler(commands.OnInteractionCreate)` 이 부분의 인자가 제대로 된 경로인지 확인하세요.

---

## 🗂️ Lotto 명령어 등록

Refactoring 작업 끝났는데, 명령어 하나 등록만 간단하게 해 볼게요.

등록이 정상적으로 잘 된 이후, 코드를 짜 보도록 합시다!

---

### main.go

```
생략

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "ping",
    Description: "Replies with pong.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

생략
```

이 부분이 명령어를 등록시켜주는 것 처럼 보이죠?

복붙해서 하나 더 작성해주도록 합시다.

```
생략

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "ping",
    Description: "Replies with pong.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "lotto",
    Description: "Challenge your luck.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

생략
```

**Description을 제외하니 오류가 발생합니다.**

분명 omitempty 으로 되어 있지만, 왜 오류가 발생하는지 원인을 살피니,

[Discord 공식 API](https://discord.com/developers/docs/interactions/application-commands#slash-commands) 에서 Description은 비어있으면 안 된다고 합니다.

즉, Go 에서는 오류가 없지만, **Discord API 에서 거부**하기 때문이라고 이해할 수 있습니다.

실제로도 이런 오류가 발생하네요.

```
Unable to create application command: HTTP 400 Bad Request, {"message": "Invalid Form Body", "code": 50035, "errors": {"description": {"_errors": [{"code": "BASE_TYPE_REQUIRED", "message": "This field is required"}]}}}
```

400, Bad Request. 이것만 봐도 우린 알 수 있죠?

그런데, 뭔가 좀 불편하지 않나요?

**같은 내용**이 작성되어 있는데, 이 부분을 뭔가 간단하게 고칠 수 있지 않을까요?

네, **반복문**이 생각나시죠?

```
생략

command := []*discordgo.ApplicationCommand{
    {
        Name:        "ping",
        Description: "Replies with pong.",
    },
    {
        Name:        "lotto",
        Description: "Challenge your luck.",
    },
}

for _, cmd := range command {
    _, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", cmd)
    if err != nil {
        log.Fatal("Unable to create application command: ", err)
    }
}
	
생략
```

이렇게, 배열과 반복문을 이용해서 간단하게 고쳐봤습니다.

뭔가 새로운 문법이 보이죠?

---

#### 배열 vs 슬라이스

**슬라이스(slice)** 는 Go의 동적 배열로, **크기가 고정되지 않고** 자유롭게 늘어날 수 있습니다.

마치, C++의 vector랑 비슷하죠.

Go 에서는 배열을 사용하듯이, 그치만 인덱스는 비워두면 됩니다.

배열 생성 방법
```
var arr1 [3]int = [3]int{1, 2, 3}
arr2 := [5]int{1, 2, 3, 4, 5}
arr3 := [...]int{1, 2, 3, 4, 5}
```

슬라이스 생성 방법
```
var slice1 []int
slice2 := []int{1, 2, 3}
slice3 := make([]int, 5) // make 함수는 따로 찾아보세요
```

뭔가 `arr3 := [...]int{1, 2, 3, 4, 5}`와 `slice2 := []int{1, 2, 3}` 가 조금 비슷해보이지 않나요?

하지만, **arr3은** 크기가 5로 고정되어, 동적 확장이 불가능한 **배열**,

**slice2는** 크기가 가변적으로 고정되어, 동적 확장이 가능한 **슬라이스**로 완전히 다릅니다.

즉, 선언 후에, 추가 가능 여부의 차이가 존재합니다.

여기선, 타입이 `*discordgo.ApplicationCommand`인 슬라이스를 선언했다고 생각하면 되겠죠?

---

#### 구조체 리터럴

구조체는 C/C++에서도 해 봤을테니, 아실 것 같고,

`discordgo.ApplicationCommand`도 까 보면 구조체이니 시간된다면 한 번 살펴보세요.

만약, 구조체가

```
type Vertex struct {
    X int
    Y int
}
```

이렇게 있다면, `v1 := Vertex{1, 2}` 이렇게 순서대로 `X=1, Y=2` 값을 할당할 수도 있고,

`v2 := Vertex{Y: 7, X: 3}` 이렇게 직접 필드명을 지정해서 값을 할당할 수도 있습니다.

`v3 := Vertex{X: 5}` 이렇게 일부 필드만 지정한다면, 나머지 필드는 모두 0으로 초기화됩니다.

이 구조체들을 한 번에 생성 및 초기화하는 문법을 **구조체 리터럴**이라고 부릅니다.

지금 `command` 변수는 슬라이스와 구조체 리터럴이 복합적으로 사용되었다고 생각할 수 있겠죠?

---

#### for ... range 반복문

Python과 뭔가 비슷하면서도 다릅니다. Python의 경우는 인터넷에서 찾아보세요.

C++에서도 range-based for문이 존재는 합니다만, Python과 조금 더 비슷한 부분이 있습니다.

Go 에서는 이렇게 사용하게 됩니다.

```
for [index], [value] := range [collection] {
    코드
}
```

이때, 역시 필요 없는 값은 `_` 를 사용해 무시할 수 있습니다.

Go 에서는 import, 변수 등 필요 없는 것이 남아있을 때, 혹은 미래의 예비상황을 위해 남겼을 때 모두 **컴파일 오류**가 나기 때문에,

꼭 **무시**해 주는 변수명, `_`을 써야 합니다.

---

### core.go

```
생략

switch i.ApplicationCommandData().Name {
    case "ping":
        handlePing(s, i)
    case "lotto":
        handleLotto(s, i)
    }

생략
```

아래처럼 `handleLotto` 함수를 만들어서, 분기시켜 주시고,

---

### commands/lotto.go

```
생략

func handleLotto(s *discordgo.Session, i *discordgo.InteractionCreate) { }
```

`commands/ping.go` 에서 코드를 복붙해서, 함수 이름을 바꾸고, 함수 내부도 깔끔하게 없애줍니다.

이제 다 됐네요. 로또 코드를 작성해 봅시다!

---

## 📜 Lotto 명령어 작성

### 