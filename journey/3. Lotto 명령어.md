# 3. Lotto 명령어

벌써 세 번째 문서에 오셨네요.

작심삼일이라는 말이 있죠?

지금까지 분량이 너무 많아서 지금이 3일째가 아니려나요..?ㅎㅎ;;

아무튼, 차근차근 가다보면 어느새 나만의 멋진 봇이 만들어질 겁니다!

오늘도 자신을 위해서 달려가고 있는 여러분들을 응원합니다.

---

[지난 문서](./2.%20Ping-Pong%20명령어.md)에서 다음에는 "입력을 받아서 출력"하는 명령어와,

"명령어가 2개 이상일 땐 어떻게 처리해야 하는지"를 다루겠다고 했습니다.

단순히 "입력 > 출력"만 하면 재미 없으니까, 어떻게 만들어볼까 고민하다가.. 로또 시스템을 직접 만들어보려고 해요.

**오늘도 지난 문서처럼 딱! 딱! 포인트만 짚으면서 넘어갑니다!**

이젠 그냥 작업하는 순서를 기준으로 설명하겠습니다. (파일 기준으로 설명X)

그래서 조금 설명 자체가 복잡해 질 수는 있지만, 따라하기에는 더욱 수월할 것입니다! 홧팅!!

---

## 🎫 로또란?

1부터 45까지 숫자 중, 6개의 숫자를 중복없이 랜덤으로 선택해야 합니다.

이때, 사용자는 수동으로 직접 번호를 선택할 수도, 자동으로 무작위 숫자를 선택할 수 있습니다.

그리고, 로또의 당첨 숫자 중 나머지 숫자에서 1개의 숫자를 보너스번호로 자동으로 선택이 되는데, 사용자가 직접 고르지 않습니다.

1등은 사용자가 선택한 6개의 번호가 모두 일치할 때,

2등은 사용자가 선택한 5개의 번호와 보너스번호가 일치할 때,

3등은 사용자가 선택한 5개의 번호가 일치할 때,

4등은 사용자가 선택한 4개의 번호가 일치할 때,

5등은 사용자가 선택한 3개의 번호가 일치할 때이고,

1등 ~ 3등은 판매액과 당첨자 수에 따라 당첨금이 달라지고,

4등은 5만원으로, 5등은 5천원으로 금액이 정해져 있습니다.

일단, 금액은 이번 문서에서는 구현하지 않을 예정입니다.

명령어의 포맷은 아래처럼 할 예정입니다.

입력: `/lotto [자동/수동] [수동일 경우, 6개의 숫자 입력]`

출력

```
입력한 번호(자동/수동일 경우엔 표시 안 함): OO OO OO OO OO OO
당첨 번호: OO OO OO OO OO OO + (보너스 숫자)
등수: O등 당첨! (O개 + 보너스 번호 일치 여부 / 혹은 "꽝!")
```

---

## 🗂️ 파일 구조

보통 간단하게 프로그램을 만든다면, 하나의 파일안에 다 때려박을 수도 있고,

[`ping.go`](./2.%20Ping-Pong%20명령어.md)처럼 하나의 명령어 파일에 때려박을수도 있습니다.

하지만, 프로젝트가 커지고, 협업하게 되고, 유지보수가 필요할 경우, 보통 파일별로 기능을 나누게 됩니다.

아래와 같은 기준으로 분리하면, 명령어가 여러 개일 때도 각 기능별로 코드가 잘 정리되고,

하나의 파일이 지나치게 커지는 문제를 예방할 수 있습니다.

~~또한, 실무에서 쌍욕을 안 먹을 수 있습니다ㅎ~~

`main.go`
- 프로그램의 **진입점** 역할로, **main함수는 항상 최대한 간단하게 유지**하는 게 좋습니다. 
- 환경설정, 세션 생성, 핸들러 등록 등만 담당하고, 실제 명령어 처리/분기는 `commands/core.go` 에서 처리합니다.

`commands/core.go`
- [`ping.go`](./2.%20Ping-Pong%20명령어.md)에서 만들었던 `OnInteractionCreate` 등 이벤트 핸들러를 처리해, 명령어 이름별로 분기합니다.
- 이 파일에서 각 명령어별 함수를 호출하게 됩니다.
- 즉, 핵심 분기와 핸들러를 별도 파일로 분리하게 됩니다.

`commands/ping.go`, `commands/lotto.go`
- 각 명령어의 실제 처리 로직만 담당합니다.
- 즉, 명령어별 파일을 분리하게 됩니다.

---

## 🗂️ Refactoring

Refactoring(리팩토링)은 코드의 기능을 변경하지 않고 내부 구조를 개선하는 작업을 의미합니다.

더욱 깔끔하고 효율적으로 만드는 작업이라고 생각하시면 됩니다.

---

### ping.go → core.go (명령어 핸들러)

기존에 ping.go 파일은

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	ping := s.HeartbeatLatency().Milliseconds()
	if i.ApplicationCommandData().Name == "ping" {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

이렇게 OnInteractionCreate 핸들러가 있었는데, 이 부분을 `commands/core.go`로 옮겨줍니다.

```
// commands/core.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
    내부 생략
}
```

여기에서, 조건문 `if i.ApplicationCommandData().Name == "ping"` 이 분기점 역할을 하고 있으므로, 조건문을 기준으로 쪼개주도록 하겠습니다.

그런데, if를 쓸까요? 아니면 switch를 쓸까요? ~~(여기까지 다 C/C++에서 배웠었죠?)~~

if문은 복잡한 조건, 논리 연산, 범위 비교, 값의 존재 여부 등 다양한 조건을 조합해서 분기할 때 사용합니다.

즉, 2~3가지 분기나 복잡한 조건에 적합합니다.

switch문은 하나의 값이 여러 가지 케이스 중 어떤 것과 일치하는지 분기할 때 사용합니다.

따라서, 분기가 많아질수록 가독성, 유지보수성이 뛰어나고, 컴파일러가 최적화(jump table 등)로 성능상 이점도 있습니다.

그래서, 저 같으면 **switch문을 사용**해서, **표현식은 1번만** 쓰고, **값에 따라서 분기**하는 방법을 선택할 예정입니다.

`i.ApplicationCommandData().Name` 를 switch문의 표현식에 넣어주고, "ping"을 case에 넣어줍니다.

그리고, 그 밑에 있는 코드들은 모두 case가 "ping"일 때로 넣어주면 되겠죠?

Go 언어에서는 각 case 블록이 실행된 후, 자동으로 switch문을 빠져나가기 때문에 break문을 쓰지 않아도 됩니다. (fallthrough 자동 방지)

따라서, 현재까지 수정한 결과는 아래와 같습니다.

```
// commands/ping.go

func OnInteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	switch i.ApplicationCommandData().Name {
	case "ping":
		ping := s.HeartbeatLatency().Milliseconds()
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: fmt.Sprintf("🏓 Pong! %dms", ping),
			},
		})
	}
}
```

---

### core.go → ping.go (명령어 처리)

`commands/core.go` 에서 `ping`의 내부 로직을 `commands/ping.go`에 함수를 만들어서 옮겨줍니다.

함수명에 `handle`을 접두사로 붙여, 나중에 명령어 처리 함수만 찾을 수 있도록, 그리고 일관성 있게 관리할 수 있도록 하겠습니다.

```
// commands/ping.go

func handlePing(s *discordgo.Session, i *discordgo.InteractionCreate) {
    생략
}
```

```
// commands/core.go

case "ping":
    handlePing(s, i)
}
```

둘 다 모두 같은 패키지(commands)에 존재하면서, Ping의 로직은 다른 패키지에서 사용할 일이 없으니깐, private로 설정햇습니다.

---

### main.go

원래는 수정해야 하지만, 패키지 이름과 함수 이름이 동일하기 때문에, 자동으로 수정이 된 것 같습니다.

혹시나 오류가 발생한다면 `Sketchbook.AddHandler(commands.OnInteractionCreate)` 이 부분의 인자가 제대로 된 경로인지 확인하세요.

---

## 🗂️ Lotto 명령어 등록

Refactoring 작업 끝났는데, 명령어 하나 등록만 간단하게 해 볼게요.

등록이 정상적으로 잘 된 이후, 코드를 짜 보도록 합시다!

---

### main.go

```
생략

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "ping",
    Description: "Replies with pong.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

생략
```

이 부분이 명령어를 등록시켜주는 것 처럼 보이죠?

복붙해서 하나 더 작성해주도록 합시다.

```
생략

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "ping",
    Description: "Replies with pong.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

_, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", &discordgo.ApplicationCommand{
    Name:        "lotto",
    Description: "Challenge your luck.",
})
if err != nil {
    log.Fatal("Unable to create application command: ", err)
}

생략
```

**Description을 제외하니 오류가 발생합니다.**

분명 omitempty 으로 되어 있지만, 왜 오류가 발생하는지 원인을 살피니,

[Discord 공식 API](https://discord.com/developers/docs/interactions/application-commands#slash-commands) 에서 Description은 비어있으면 안 된다고 합니다.

즉, Go 에서는 오류가 없지만, **Discord API 에서 거부**하기 때문이라고 이해할 수 있습니다.

실제로도 이런 오류가 발생하네요.

```
Unable to create application command: HTTP 400 Bad Request, {"message": "Invalid Form Body", "code": 50035, "errors": {"description": {"_errors": [{"code": "BASE_TYPE_REQUIRED", "message": "This field is required"}]}}}
```

400, Bad Request. 이것만 봐도 우린 알 수 있죠?

그런데, 뭔가 좀 불편하지 않나요?

**같은 내용**이 작성되어 있는데, 이 부분을 뭔가 간단하게 고칠 수 있지 않을까요?

네, **반복문**이 생각나시죠?

```
생략

command := []*discordgo.ApplicationCommand{
    {
        Name:        "ping",
        Description: "Replies with pong.",
    },
    {
        Name:        "lotto",
        Description: "Challenge your luck.",
    },
}

for _, cmd := range command {
    _, err = Sketchbook.ApplicationCommandCreate(Sketchbook.State.User.ID, "", cmd)
    if err != nil {
        log.Fatal("Unable to create application command: ", err)
    }
}
	
생략
```

이렇게, 배열과 반복문을 이용해서 간단하게 고쳐봤습니다.

뭔가 새로운 문법이 보이죠?

---

#### 배열 vs 슬라이스

**슬라이스(slice)** 는 Go의 동적 배열로, **크기가 고정되지 않고** 자유롭게 늘어날 수 있습니다.

마치, C++의 vector랑 비슷하죠.

Go 에서는 배열을 사용하듯이, 그치만 인덱스는 비워두면 됩니다.

배열 생성 방법
```
var arr1 [3]int = [3]int{1, 2, 3}
arr2 := [5]int{1, 2, 3, 4, 5}
arr3 := [...]int{1, 2, 3, 4, 5}
```

슬라이스 생성 방법
```
var slice1 []int
slice2 := []int{1, 2, 3}
slice3 := make([]int, 5) // make 함수는 따로 찾아보세요
```

뭔가 `arr3 := [...]int{1, 2, 3, 4, 5}`와 `slice2 := []int{1, 2, 3}` 가 조금 비슷해보이지 않나요?

하지만, **arr3은** 크기가 5로 고정되어, 동적 확장이 불가능한 **배열**,

**slice2는** 크기가 가변적으로 고정되어, 동적 확장이 가능한 **슬라이스**로 완전히 다릅니다.

즉, 선언 후에, 추가 가능 여부의 차이가 존재합니다.

여기선, 타입이 `*discordgo.ApplicationCommand`인 슬라이스를 선언했다고 생각하면 되겠죠?

---

#### 구조체 리터럴

구조체는 C/C++에서도 해 봤을테니, 아실 것 같고,

`discordgo.ApplicationCommand`도 까 보면 구조체이니 시간된다면 한 번 살펴보세요.

만약, 구조체가

```
type Vertex struct {
    X int
    Y int
}
```

이렇게 있다면, `v1 := Vertex{1, 2}` 이렇게 순서대로 `X=1, Y=2` 값을 할당할 수도 있고,

`v2 := Vertex{Y: 7, X: 3}` 이렇게 직접 필드명을 지정해서 값을 할당할 수도 있습니다.

`v3 := Vertex{X: 5}` 이렇게 일부 필드만 지정한다면, 나머지 필드는 모두 0으로 초기화됩니다.

이 구조체들을 한 번에 생성 및 초기화하는 문법을 **구조체 리터럴**이라고 부릅니다.

지금 `command` 변수는 슬라이스와 구조체 리터럴이 복합적으로 사용되었다고 생각할 수 있겠죠?

---

#### for ... range 반복문

Python과 뭔가 비슷하면서도 다릅니다. Python의 경우는 인터넷에서 찾아보세요.

C++에서도 range-based for문이 존재는 합니다만, Python과 조금 더 비슷한 부분이 있습니다.

Go 에서는 이렇게 사용하게 됩니다.

```
for [index], [value] := range [collection] {
    코드
}
```

이때, 역시 필요 없는 값은 `_` 를 사용해 무시할 수 있습니다.

Go 에서는 import, 변수 등 필요 없는 것이 남아있을 때, 혹은 미래의 예비상황을 위해 남겼을 때 모두 **컴파일 오류**가 나기 때문에,

꼭 **무시**해 주는 변수명, `_`을 써야 합니다.

---

### core.go

```
생략

switch i.ApplicationCommandData().Name {
    case "ping":
        handlePing(s, i)
    case "lotto":
        handleLotto(s, i)
    }

생략
```

아래처럼 `handleLotto` 함수를 만들어서, 분기시켜 주시고,

---

### commands/lotto.go

```
생략

func handleLotto(s *discordgo.Session, i *discordgo.InteractionCreate) { }
```

`commands/ping.go` 에서 코드를 복붙해서, 함수 이름을 바꾸고, 함수 내부도 깔끔하게 없애줍니다.

이제 다 됐네요. 로또 코드를 작성해 봅시다!

---

## 📜 Lotto 코드 작성

### Input: `/lotto [수동/자동] [수동일 경우, 6개의 숫자 입력]`

먼저, 사용자에게 수동인지 자동인지의 여부부터 받는 작업부터 해 봅시다.

원래는 자동일 경우, `lotto 자동`으로, 수동일 경우, `/lotto 1 2 3 4 5 6` 처럼 하고 싶었으나,

이렇게 설계할 경우, Discord 에서 제공하는 자동완성, 입력 가이드, 타입 검증 등의 UX 이점을 포기해야 하기 때문에,

수동일 경우, 바로 숫자 입력이 아니라, `/lotto 수동 1 2 3 4 5 6` 으로 변경했습니다.

#### mode 입력받기 - [main.go](../main.go)

Option 까지 받아야 하기 때문에,

```
{
    Name:        "lotto",
    Description: "Challenge your luck.",
}
```

여기에 Option을 추가해 줍시다.

`command := []*discordgo.ApplicationCommand{ 생략 }` 에서 타입을 자세히 보면,

```

// ApplicationCommand represents an application's slash command.
type ApplicationCommand struct {
	ID                string                 `json:"id,omitempty"`
	ApplicationID     string                 `json:"application_id,omitempty"`
	GuildID           string                 `json:"guild_id,omitempty"`
	Version           string                 `json:"version,omitempty"`
	Type              ApplicationCommandType `json:"type,omitempty"`
	Name              string                 `json:"name"`
	NameLocalizations *map[Locale]string     `json:"name_localizations,omitempty"`

	// NOTE: DefaultPermission will be soon deprecated. Use DefaultMemberPermissions and Contexts instead.
	DefaultPermission        *bool  `json:"default_permission,omitempty"`
	DefaultMemberPermissions *int64 `json:"default_member_permissions,string,omitempty"`
	NSFW                     *bool  `json:"nsfw,omitempty"`

	// Deprecated: use Contexts instead.
	DMPermission     *bool                         `json:"dm_permission,omitempty"`
	Contexts         *[]InteractionContextType     `json:"contexts,omitempty"`
	IntegrationTypes *[]ApplicationIntegrationType `json:"integration_types,omitempty"`

	// NOTE: Chat commands only. Otherwise it mustn't be set.

	Description              string                      `json:"description,omitempty"`
	DescriptionLocalizations *map[Locale]string          `json:"description_localizations,omitempty"`
	Options                  []*ApplicationCommandOption `json:"options"`
}
```

이렇게 나옵니다.

여기서, Options는 `[]*ApplicationCommandOption` 타입이라고 되어 있네요.

한 번 더, 자세히 들어가 보면

```
// ApplicationCommandOption represents an option/subcommand/subcommands group.
type ApplicationCommandOption struct {
	Type                     ApplicationCommandOptionType `json:"type"`
	Name                     string                       `json:"name"`
	NameLocalizations        map[Locale]string            `json:"name_localizations,omitempty"`
	Description              string                       `json:"description,omitempty"`
	DescriptionLocalizations map[Locale]string            `json:"description_localizations,omitempty"`
	// NOTE: This feature was on the API, but at some point developers decided to remove it.
	// So I commented it, until it will be officially on the docs.
	// Default     bool                              `json:"default"`

	ChannelTypes []ChannelType               `json:"channel_types"`
	Required     bool                        `json:"required"`
	Options      []*ApplicationCommandOption `json:"options"`

	// NOTE: mutually exclusive with Choices.
	Autocomplete bool                              `json:"autocomplete"`
	Choices      []*ApplicationCommandOptionChoice `json:"choices"`
	// Minimal value of number/integer option.
	MinValue *float64 `json:"min_value,omitempty"`
	// Maximum value of number/integer option.
	MaxValue float64 `json:"max_value,omitempty"`
	// Minimum length of string option.
	MinLength *int `json:"min_length,omitempty"`
	// Maximum length of string option.
	MaxLength int `json:"max_length,omitempty"`
}
```

구조체인데, 여기서 "Type", "Name", "Description", "Required", "Choices" 이 정도 필요하겠네요.

근데, 새로운 타입들이 보이네요.

먼저, "Type"은 `ApplicationCommandOptionType` 타입이라던데, 자세히 보면

```
// ApplicationCommandOptionType indicates the type of a slash command's option.
type ApplicationCommandOptionType uint8
```

이렇게.. 좀 "그래서 어쩌라고"라고 생각하려나요?

그런데, 그 밑까지 보면

```
// Application command option types.
const (
	ApplicationCommandOptionSubCommand      ApplicationCommandOptionType = 1
	ApplicationCommandOptionSubCommandGroup ApplicationCommandOptionType = 2
	ApplicationCommandOptionString          ApplicationCommandOptionType = 3
	ApplicationCommandOptionInteger         ApplicationCommandOptionType = 4
	ApplicationCommandOptionBoolean         ApplicationCommandOptionType = 5
	ApplicationCommandOptionUser            ApplicationCommandOptionType = 6
	ApplicationCommandOptionChannel         ApplicationCommandOptionType = 7
	ApplicationCommandOptionRole            ApplicationCommandOptionType = 8
	ApplicationCommandOptionMentionable     ApplicationCommandOptionType = 9
	ApplicationCommandOptionNumber          ApplicationCommandOptionType = 10
	ApplicationCommandOptionAttachment      ApplicationCommandOptionType = 11
)
```

이런식으로 상수로 정의되어 있어, 우리는 왼쪽에 있는 값만 쓰면 될 것 같네요.

지금은, "수동"인지 "자동"인지 문자열을 받으면 되니깐, `ApplicationCommandOptionString`을 선택할게요.

그리고, "Choices" 도 새로운 타입이네요? 자세히 봐 볼게요.

```
// ApplicationCommandOptionChoice represents a slash command option choice.
type ApplicationCommandOptionChoice struct {
	Name              string            `json:"name"`
	NameLocalizations map[Locale]string `json:"name_localizations,omitempty"`
	Value             interface{}       `json:"value"`
}
```

여기서, "NameLocalizations" 는 'omitempty' 이니깐, Name과 Value만 넣어주도록 하겠습니다.

그리고, 순서는 상관 없으니, 저는 이전에 정의했던 형식에 맞춰 Options를 작성하겠습니다.

```
생략

{
    Name:        "lotto",
    Description: "Challenge your luck.",
    Options: []*discordgo.ApplicationCommandOption{
        {
            Name:        "mode",
            Description: "수동/자동",
            Type:        discordgo.ApplicationCommandOptionString,
            Required:    true,
            Choices: []*discordgo.ApplicationCommandOptionChoice{
                {Name: "수동", Value: "수동"},
                {Name: "자동", Value: "자동"},
            },
        },
    },
},

생략
```

---

#### mode 입력받기 - [lotto.go](../commands/lotto.go)

잘 입력받았는지부터 테스트 해 볼까요?

만약, "수동"을 입력받았다면 `lotto 명령어: 수동`을 출력하고, "자동"을 입력받았다면 `lotto 명령어: 자동`을 출력하도록 할게요.

그러기 위해선 mode의 값부터 받아와야 하겠네요.

그 전에, [이전 문서](./2.%20Ping-Pong%20명령어.md)에서는 무지성으로 "세션 쓰라니깐 세션으로 써야하나보다, 인터렉션을 쓰라니깐 인터렉션으로 써야하나보다" 라고 넘겼을텐데,

여기서부턴 조금 명확하게 알고 넘어갈 필요가 있어 보여요.

이 부분도, 네트워크 프로그래밍을 했다면 쉽게 넘어갈 수 있겠지만,

저번 문서에서도 간략하게 설명했으니, 이번문서에서도 간략하게만 설명하고 넘어갈게요.

---

##### 세션(Session)

사전에 따르면, "클라이언트 내의 서비스 요구 처리 프로그램과 서버 내의 서비스 응답 처리 프로그램 사이에 링크가 설정되는 것. 네트워크 입장에서 보면, 두 사용자 사이에서 서비스 구현을 위하여 필요한 자원을 하나로 모을 수 있는 연결을 의미한다." 라고 되어 있습니다.

즉, **어떠한 연결 상태를 관리** 하는 것이라고 생각할 수 있습니다.

`main.go`에서 뭔가 생각나시나요?

Discord 봇이랑 연결하기 위해, `err = Sketchbook.Open()`으로, 연결을 끊을 때는 `Sketchbook.Close()`으로 처리했던게 생각난다면 이 문서를 읽는 보람이 있네요 :)

그런데, 세션은 이것을 기초로 해서, 더욱 많은 작업들을 진행할 수 있습니다.

예를 들면, 디스코드에서는 **이벤트 핸들러 등록, 명령어 등록 및 관리, 메세지 송수신, 유저/채널/서버 정보 조회, 음성 채널 연결 및 제어 등**의 작업들이 모두 **세션(Session)** 을 통해 이루어집니다.

이미, 우리는 "이벤트 핸들러 등록, 명령어 등록 및 관리, 메세지 송수신" 작업들을 모두 경험해 봤는데, 이럴 때 마다 모두 "세션"에서 부터 시작해 `. (dot operator)`를 통해 내부적으로 들어감을 알 수 있습니다.

즉, 세션은 **디스코드와 실시간으로 소통하면서, 봇의 모든 동작의 출발점이자 중심이 되는 역할**이라고 생각하면 됩니다.

---

##### 인터렉션(Interaction)

Interaction을 한국어로는 "상호작용", 즉 **개별 상호작용 이벤트가 발생할 때마다 생성되는 데이터 객체**입니다.

예를 들면, "어떤 명령어가 실행됐는지", "사용자가 어떤 옵션(파라미터)을 입력했는지", "누가, 어느 채널에서 실행했는지" 등을 알 수 있는데,

이들의 공통점은 모두 **이번 상호작용에 대한 모든 맥락과 입력값**을 확인할 수 있다는 점이니다.

즉, **명령어 실행과 관련된 모든 정보의 출발점**이라고 생각하면 됩니다.

---

#### 다시! mode 입력받기 - [lotto.go](../commands/lotto.go)

자, 그럼 이제 `mode` 를 입력받아 볼까요?

`mode`는 명령어의 정보(Option) 중 일부이니까, 인터렉션(`i`) 부터 출발합니다!

`i.` 까지 친 후, "명령어"의 영어인 `Command`까지만 쳐도, `i.ApplicationCommandData()`가 나오네요.

여기서, 우리는 명령어의 "정보"인 Option이 궁금하니까, `Options`을 치니깐 나오고,

위에서 `[]*discordgo.ApplicationCommandOption` 타입이라고 했었으니까, (혹은 `i.ApplicationCommandData().Options`까지 쳤을 때 타입이 뜨니깐)

배열로 저장되겠죠?

첫 번째 인자이니깐, `[0]`까지 붙여줘서, `i.ApplicationCommandData().Options[0]`까지 완성해 주고,

지금 Options를 자세히 보면, 타입이 `[]*ApplicationCommandInteractionDataOption`라고 하니깐, 이것도 자세히 들어가보면,

```
type ApplicationCommandInteractionDataOption struct {
	Name string                       `json:"name"`
	Type ApplicationCommandOptionType `json:"type"`
	// NOTE: Contains the value specified by Type.
	Value   interface{}                                `json:"value,omitempty"`
	Options []*ApplicationCommandInteractionDataOption `json:"options,omitempty"`

	// NOTE: autocomplete interaction only.
	Focused bool `json:"focused,omitempty"`
}
```

이렇게 나오게 되는데, 여기서 처음에 `main.go` 에서 명령어 등록할 때,

```
Choices: []*discordgo.ApplicationCommandOptionChoice{
    {Name: "수동", Value: "수동"},
    {Name: "자동", Value: "자동"},
},
```

이 부분에서 사용했던 `Value`를 가져오기 위해, `Value`까지만 치면 여러 함수가 또 나옵니다.

지금, `Value` 자체의 타입이 `interface{}`인데, 밑에 조금 내려서 찾아보면 `string`타입으로 반환시켜주는 함수가 보이네요.

이걸, `mode` 라는 변수에 저장시키겠습니다.

`mode := i.ApplicationCommandData().Options[0].StringValue()` 이렇게요.


그리고, 그 밑에는 [ping](../commands/ping.go)과 비슷하니, 복붙해서 일부만 변경해 주겠습니다.

```
mode := i.ApplicationCommandData().Options[0].StringValue()

err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
    Type: discordgo.InteractionResponseChannelMessageWithSource,
    Data: &discordgo.InteractionResponseData{
        Content: fmt.Sprintf("🎫 lotto 명령어: %s", mode),
    },
})

if err != nil {
    log.Println("Failed to respond to ping: ", err)
    replyError(s, i)
    return
}
```

여기서, "수동/자동" 이외의 값이 오는지는 왜 체크하지 않는지 궁금하시나요?

직접 한 번 해 보세요.

디스코드 자체에서 예외처리를 해 줍니다.